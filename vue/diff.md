简单来说，diff算法有以下过程

- 先同级比较再比较子节点
- 先判断一方有子节点和一方没有子节点的情况。如果新的一方有子节点，旧的一方没有，相当于新的子节点替代了原来没有的节点；同理，如果新的一方没有子节点，旧的一方有，相当于要把老的节点删除。
- 再来比较都有子节点的情况，这里是diff的核心。首先会通过判断两个节点的key、tag、isComment、data同时定义或不定义以及当标签类型为input的时候type相不相同来确定两个节点是不是相同的节点，如果不是的话就将新节点替换旧节点。
- 如果是相同节点的话才会进入到patchVNode阶段。在这个阶段核心是采用双端比较的算法，同时从新旧节点的两端进行比较，在这个过程中，会用到模版编译时的静态标记配合key来跳过对比静态节点，如果不是的话再进行其它的比较。




1. 我们在数据进行更新的时候，会走object.definePrototy的setter触发dep.notify通知观察者进行更新，数据更新的话会走render生成新的 VNode 这时候会调用patch（vNode， oldNode）比较
2. 先判断是不是相同的节点，不同直接老节点被新节点替换， 相同这个时候我们需要调用patchNode
3. patchNode做了以下操作
   1. 找到对应的真实节点，判断是不是指向同一个对象，是的话直接return
   2. 如果都有文本节点，不相等直接进行替换
   3. 如果oldNode有子节点，新的没有，直接去掉
   4. 如果newNode有子节点，老的没有，则将newNode的子节点真实化之后添加到el
   5. 都有子节点，那么执行updateChildren比较子节点
4. updateChildren做了那些操作
   1. 设置新旧节点的头尾指针
   2. oldNode和newNode各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx>EndIdx表明oldCh和vCh至少有一个已经遍历完了，就会结束比较。